package com.tongxin.caihong.view.window;import android.animation.ValueAnimator;import android.annotation.SuppressLint;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.PixelFormat;import android.graphics.Point;import android.os.Build;import android.view.Gravity;import android.view.LayoutInflater;import android.view.MotionEvent;import android.view.View;import android.view.ViewGroup;import android.view.ViewParent;import android.view.WindowManager;import android.view.inputmethod.InputMethodManager;import android.webkit.WebView;import androidx.annotation.Nullable;import com.tongxin.caihong.MyApplication;import com.tongxin.caihong.R;import com.tongxin.caihong.helper.AvatarHelper;import com.tongxin.caihong.ui.base.ActivityStack;import com.tongxin.caihong.util.DisplayUtil;import com.tongxin.caihong.view.window.rom.RomUtils;import com.makeramen.roundedimageview.RoundedImageView;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.UUID;import static android.content.Context.WINDOW_SERVICE;public class WindowUtil {    // private static final int mViewWidth = 100;    private static final int mViewWidth = 51;    private final Map<String, WebView> webViewCache = new LinkedHashMap<>();    private WindowManager mWindowManager;    private WindowManager.LayoutParams mLayoutParams;    private View mView;    private View rlFloatingRoot;    private RoundedImageView ivIcon;    private WindowUtil() {    }    public static WindowUtil getInstance() {        return SingletonInstance.INSTANCE;    }    public boolean checkCanPush() {        return webViewCache.size() < 5;    }    public boolean push(Context ctx, String key, WebView webView) {        if (webView == null) {            return false;        }        // 最多5个，        if (webViewCache.size() >= 5) {            return false;        }        if (key == null) {            key = UUID.randomUUID().toString();        }        webViewCache.put(key, webView);        ctx.startService(new Intent(ctx, WindowShowService.class));        updateView();        return true;    }    @Nullable    public WebView pop(Context ctx, String key) {        WebView ret = webViewCache.remove(key);        if (webViewCache.isEmpty()) {            ctx.stopService(new Intent(ctx, WindowShowService.class));        }        updateView();        return ret;    }    private void updateView() {        if (ivIcon == null) {            return;        }        if (webViewCache.isEmpty()) {            ivIcon.setImageDrawable(null);            return;        }        List<Bitmap> list = new ArrayList<>(webViewCache.size());        for (WebView value : webViewCache.values()) {            value.getSettings().setSavePassword(false);            value.getSettings().setAllowFileAccess(false);            Bitmap icon = value.getFavicon();            if (icon == null) {                icon = BitmapFactory.decodeResource(ivIcon.getResources(), R.mipmap.ic_float_window_link);            }            list.add(icon);        }        AvatarHelper.getInstance().displayJoinedBitmap(list, ivIcon);    }    public void showPermissionWindow(Context context, OnPermissionListener onPermissionListener) {        if (webViewCache.isEmpty()) {            // 可能因崩溃之类原因导致service自动重启，没数据就不显示，            context.stopService(new Intent(context, WindowShowService.class));            return;        }        if (RomUtils.checkFloatWindowPermission(context)) {            showWindow(context);        } else {            onPermissionListener.showPermissionDialog();        }    }    @SuppressLint("CheckResult")    private void showWindow(Context context) {        if (null == mWindowManager && null == mView) {            mWindowManager = (WindowManager) context.getSystemService(WINDOW_SERVICE);            mView = LayoutInflater.from(context).inflate(R.layout.article_window, null);            rlFloatingRoot = mView.findViewById(R.id.rlFloatingRoot);            ivIcon = mView.findViewById(R.id.ivIcon);            updateView();            initListener(context);            mLayoutParams = new WindowManager.LayoutParams();            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {                mLayoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;            } else {                mLayoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;            }            mLayoutParams.format = PixelFormat.RGBA_8888;   //窗口透明            mLayoutParams.gravity = Gravity.RIGHT | Gravity.CENTER;  //窗口位置            mLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;            mLayoutParams.width = DisplayUtil.dip2px(context, mViewWidth);            mLayoutParams.height = DisplayUtil.dip2px(context, mViewWidth);            mWindowManager.addView(mView, mLayoutParams);        }    }    public void dismissWindow() {        webViewCache.clear();        if (mWindowManager != null && mView != null) {            mWindowManager.removeViewImmediate(mView);            // mWindowManager.removeViewImmediate(mCancelView);            mWindowManager = null;            mView = null;        }    }    private void initListener(final Context context) {        mView.setOnClickListener(v -> {            hideKeyboard(context);            int[] location = new int[2];            mView.getLocationOnScreen(location);            int statusBarHeight = 0;            int resourceId = context.getResources().getIdentifier("status_bar_height", "dimen", "android");            if (resourceId > 0) {                statusBarHeight = context.getResources().getDimensionPixelSize(resourceId);            }            Point point = new Point(location[0] + mView.getWidth() / 2, location[1] + mView.getHeight() / 2 - statusBarHeight);            LayoutInflater inflater = (LayoutInflater) context                    .getSystemService(Context.LAYOUT_INFLATER_SERVICE);            ViewGroup view = (ViewGroup) inflater.inflate(R.layout.dialog_web_floating_list, null);            WebFloatingListWindow window = new WebFloatingListWindow(view, point, webViewCache, (position, item) -> {                pop(context, item.key);            });            window.setAnimationStyle(android.R.style.Animation);            rlFloatingRoot.setVisibility(View.INVISIBLE); // 不能隐藏mView,            rlFloatingRoot.post(() -> {                mLayoutParams.width = ViewGroup.LayoutParams.MATCH_PARENT;                mLayoutParams.height = ViewGroup.LayoutParams.MATCH_PARENT;                updateViewLayout();            });            window.addOnDismissListener(() -> {                mLayoutParams.width = DisplayUtil.dip2px(context, mViewWidth);                mLayoutParams.height = DisplayUtil.dip2px(context, mViewWidth);                updateViewLayout();                rlFloatingRoot.postDelayed(() -> {                    rlFloatingRoot.setVisibility(View.VISIBLE);                }, 200);            });            window.showAtLocation(v, Gravity.CENTER, 0, 0);        });        //设置触摸滑动事件        mView.setOnTouchListener(new View.OnTouchListener() {            private int mStartX, mLastX, mStartY, mLastY;            private boolean moving = false;            private int screenWidth = -1;            @Override            public boolean onTouch(View v, MotionEvent event) {                if (screenWidth == -1) {                    screenWidth = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();                }                int action = event.getAction();                if (MotionEvent.ACTION_DOWN == action) {                    mStartX = mLastX = (int) event.getRawX();                    mStartY = mLastY = (int) event.getRawY();                } else if (MotionEvent.ACTION_MOVE == action) {                    int dx = (int) event.getRawX() - mLastX;                    int dy = (int) event.getRawY() - mLastY;                    mLayoutParams.x = mLayoutParams.x - dx;                    mLayoutParams.y = mLayoutParams.y + dy;                    mWindowManager.updateViewLayout(v, mLayoutParams);                    mLastX = (int) event.getRawX();                    mLastY = (int) event.getRawY();                    if (!moving) {                        rlFloatingRoot.setBackgroundResource(R.drawable.floating_bg_normal);                    }                    moving = true;                } else if (MotionEvent.ACTION_UP == action) {                    int dx = (int) event.getRawX() - mStartX;                    int dy = (int) event.getRawY() - mStartY;                    moving = false;                    if (event.getRawX() > screenWidth / 2f) {                        rlFloatingRoot.setBackgroundResource(R.drawable.floating_bg_right);                    } else {                        rlFloatingRoot.setBackgroundResource(R.drawable.floating_bg_left);                    }                    //这里做动画贴边效果                    int width = v.getWidth();                    int halfOfScreenWidth = screenWidth / 2;                    ValueAnimator anim;                    if (event.getRawX() > halfOfScreenWidth) {                        anim = ValueAnimator.ofFloat(mLayoutParams.x, 0);                    } else {                        anim = ValueAnimator.ofFloat(mLayoutParams.x, screenWidth - width);                    }                    anim.setDuration(250);                    anim.addUpdateListener(animListener(v));                    anim.start();                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {                        return true;                    }                }                return false;            }            private ValueAnimator.AnimatorUpdateListener animListener(View v) {                return animation -> {                    Float value = (Float) animation.getAnimatedValue();                    mLayoutParams.x = value.intValue();                    mWindowManager.updateViewLayout(v, mLayoutParams);                };            }        });    }    private void hideKeyboard(Context ctx) {        Activity topActivity = null;        try {            topActivity = ActivityStack.getInstance().peek();        } catch (Exception ignored) {        }        if (topActivity == null || topActivity.getCurrentFocus() == null) {            return;        }        InputMethodManager imm = (InputMethodManager) ctx.getSystemService(Context.INPUT_METHOD_SERVICE);        imm.hideSoftInputFromWindow(topActivity.getCurrentFocus().getWindowToken(), 0);    }    private boolean isRemoveAllView(int x1, int y1, int x2, int y2) {        //利用勾股定理计算出两个圆心（悬浮窗，右下角的圆弧）的距离，然后判断两者是否重合        double radius = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));        return radius <= DisplayUtil.dip2px(MyApplication.getContext(), (float) (100 * Math.sqrt(2) + 200));    }    private void updateViewLayout() {        if (null != mView && null != mLayoutParams) {            mWindowManager.updateViewLayout(mView, mLayoutParams);        }    }    public void onActivityDestroy(WebView webView) {        if (webView == null) {            return;        }        if (webViewCache.containsValue(webView)) {            return;        }        webView.stopLoading();        webView.removeAllViewsInLayout();        webView.removeAllViews();        webView.setWebViewClient(null);        ViewParent parent = webView.getParent();        if (parent != null) {            ((ViewGroup) parent).removeView(webView);        }        webView.clearHistory();        webView.clearCache(true);        webView.destroy();    }    interface OnPermissionListener {        void showPermissionDialog();    }    private static class SingletonInstance {        @SuppressLint("StaticFieldLeak")        private static final WindowUtil INSTANCE = new WindowUtil();    }}