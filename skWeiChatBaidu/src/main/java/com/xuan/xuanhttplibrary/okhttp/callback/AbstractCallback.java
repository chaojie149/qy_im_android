package com.xuan.xuanhttplibrary.okhttp.callback;import android.content.Context;import android.os.Handler;import android.os.Looper;import android.util.Log;import androidx.annotation.NonNull;import com.tongxin.caihong.MyApplication;import com.tongxin.caihong.Reporter;import com.tongxin.caihong.helper.LoginHelper;import com.tongxin.caihong.helper.LoginSecureHelper;import com.tongxin.caihong.ui.base.CoreManager;import com.tongxin.caihong.util.LogUtils;import com.xuan.xuanhttplibrary.okhttp.HttpUtils;import com.xuan.xuanhttplibrary.okhttp.builder.BaseBuilder;import com.xuan.xuanhttplibrary.okhttp.result.Result;import java.io.IOException;import java.net.ConnectException;import java.net.SocketTimeoutException;import java.util.Objects;import okhttp3.Call;import okhttp3.Callback;import okhttp3.Request;import okhttp3.Response;import okhttp3.internal.Util;public abstract class AbstractCallback<T> implements Callback {    // 切到主线程再回调子类方法，    protected boolean mainThreadCallback;    private Handler mDelivery;    private BaseBuilder baseBuilder;    private boolean retrying = false;    public AbstractCallback() {        this(true);    }    /**     * @param mainThreadCallback true表示切到主线程再回调子类方法，     */    public AbstractCallback(boolean mainThreadCallback) {        this.mainThreadCallback = mainThreadCallback;        mDelivery = new Handler(Looper.getMainLooper());    }    public abstract void onResponse(T result);    public abstract void onError(Call call, Exception e);    @Override    public void onFailure(Call call, IOException e) {        //noinspection ConstantConditions        if (call == null) {            // url创建request异常时这call为空，            Log.i(HttpUtils.TAG, "创建请求失败", e);        } else {            Request request = call.request();            Log.i(HttpUtils.TAG, "服务器请求失败" + request.url(), e);        }        if (e instanceof ConnectException) {            Log.i(HttpUtils.TAG, "ConnectException", e);        }        if (e instanceof SocketTimeoutException) {            Log.i(HttpUtils.TAG, "SocketTimeoutException", e);        }        errorData(call, e);    }    @Override    public void onResponse(Call call, Response response) throws IOException {        Request request = call.request();        if (response.code() == 200) {            try {                String body = response.body().string();                Log.i(HttpUtils.TAG, "服务器数据包：" + request.url() + "\n" + body);                T result = Objects.requireNonNull(parseResponse(call, body), body);                checkResult(result);            } catch (Exception e) {                LogUtils.log(response);                Reporter.post("json解析失败, ", e);                Log.i(HttpUtils.TAG, "数据解析异常:" + request.url() + "\n" + e.getMessage());                errorData(call, new Exception("数据解析异常"));            }        } else {            Log.i(HttpUtils.TAG, "服务器请求异常" + request.url() + "\n" + response.code());            errorData(call, new Exception("服务器请求异常" + response.code()));        }        Util.closeQuietly(response.body());    }    private void checkResult(T result) {        if (result instanceof Result) {            int resultCode = ((Result) result).getResultCode();            if (resultCode == Result.CODE_TOKEN_ERROR) {                // accessToken过期时尝试自动登录刷新accessToken，如果loginToken也过期或者其他原因就正常提示登录过期，如果自动登录成功就重新请求接口，                Context context = MyApplication.getContext();                CoreManager coreManager = CoreManager.getInstance(context);                if (baseBuilder != null && baseBuilder.supportRetry() && coreManager.getSelf() != null && !retrying) {                    retrying = true;                    LoginSecureHelper.autoLogin(context, coreManager, t -> {                        callTokenError();                        // 保留原逻辑，token过期同时也回调callback,                        successData(result);                    }, () -> {                        baseBuilder.rebuild().execute(this);                    });                    return;                } else {                    callTokenError();                }            }        }        successData(result);    }    // 保留原代码和注释，    private void callTokenError() {        // 状态置为STATUS_USER_TOKEN_CHANGE会出现“账号在其他设备登录”的提示，应置为STATUS_USER_TOKEN_OVERDUE，提示登录过期        // MyApplication.getInstance().mUserStatus = LoginHelper.STATUS_USER_TOKEN_CHANGE;        MyApplication.getInstance().mUserStatus = LoginHelper.STATUS_USER_TOKEN_OVERDUE;        LoginHelper.broadcastLogout(MyApplication.getContext());    }    @NonNull    abstract protected T parseResponse(Call call, String body);    protected void successData(final T t) {        if (mainThreadCallback) {            mDelivery.post(() -> onResponse(t));        } else {            onResponse(t);        }    }    protected void errorData(final Call call, final Exception e) {        if (mainThreadCallback) {            mDelivery.post(() -> onError(call, e));        } else {            onError(call, e);        }    }    public void attach(BaseBuilder baseBuilder) {        this.baseBuilder = baseBuilder;    }}